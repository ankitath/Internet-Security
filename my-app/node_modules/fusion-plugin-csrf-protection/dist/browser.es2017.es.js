import { createToken, createPlugin, unescape } from 'fusion-core';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const methods = {
  POST: 1,
  PUT: 1,
  PATCH: 1,
  DELETE: 1
};
function verifyMethod(method) {
  return methods[method];
}
function verifyExpiry(token, expire) {
  if (!token) return false;
  const [timestamp] = token.split('-');
  const elapsed = Math.round(Date.now() / 1000) - Number(timestamp);
  if (isNaN(elapsed) || elapsed < 0 || elapsed >= expire) return false;
  return true;
}
const CsrfExpireToken = createToken('CsrfExpireToken');
const CsrfIgnoreRoutesToken = createToken('CsrfIgnoreRoutesToken');
const FetchForCsrfToken = createToken('FetchForCsrfToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
const plugin$2 = true && createPlugin({
  deps: {
    fetch: FetchForCsrfToken,
    expire: CsrfExpireToken.optional
  },
  provides: ({
    fetch,
    expire = 86400
  }) => {
    const prefix = window.__ROUTE_PREFIX__ || ''; // created by fusion-core/src/server

    const tokenElement = document.getElementById('__CSRF_TOKEN__');
    let token = tokenElement ? JSON.parse(unescape(tokenElement.textContent)) : '';

    let fetchWithCsrfToken = (url, options) => {
      if (!options) options = {}; // $FlowFixMe

      const isCsrfMethod = verifyMethod(options.method || 'GET');
      const isValid = verifyExpiry(String(token), expire);
      const isTokenRequired = !isValid || !token;

      if (isCsrfMethod && isTokenRequired) {
        // TODO(#3) don't append prefix if injected fetch also injects prefix
        return fetch(prefix + '/csrf-token', {
          method: 'POST',
          credentials: 'same-origin'
        }).then(r => {
          token = r.headers.get('x-csrf-token');
          return request();
        });
      } else {
        return request();
      }

      function request() {
        // $FlowFixMe
        return fetch(prefix + url, _objectSpread({}, options, {
          credentials: 'same-origin',
          headers: _objectSpread({}, options && options.headers || {}, {
            'x-csrf-token': token
          })
        }));
      }
    };

    return fetchWithCsrfToken;
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = plugin$2;

export default index;
export { FetchForCsrfToken, CsrfExpireToken, CsrfIgnoreRoutesToken };
//# sourceMappingURL=browser.es2017.es.js.map
