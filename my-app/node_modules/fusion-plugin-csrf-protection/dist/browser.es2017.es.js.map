{"version":3,"file":"browser.es2017.es.js","sources":["../src/shared.js","../src/server.js","../src/browser.js","../src/index.js"],"sourcesContent":["/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {createToken} from 'fusion-core';\nimport type {Token} from 'fusion-core';\nimport type {Fetch} from 'fusion-tokens';\n\nconst methods = {POST: 1, PUT: 1, PATCH: 1, DELETE: 1};\n\nexport function verifyMethod(\n  method: string | $Keys<typeof methods>\n): $Values<typeof methods> {\n  return methods[method];\n}\nexport function verifyExpiry(token: ?string, expire: number): boolean {\n  if (!token) return false;\n  const [timestamp] = token.split('-');\n  const elapsed = Math.round(Date.now() / 1000) - Number(timestamp);\n  if (isNaN(elapsed) || elapsed < 0 || elapsed >= expire) return false;\n  return true;\n}\n\nexport const CsrfExpireToken: Token<number> = createToken('CsrfExpireToken');\nexport const CsrfIgnoreRoutesToken: Token<Array<string>> = createToken(\n  'CsrfIgnoreRoutesToken'\n);\nexport const FetchForCsrfToken: Token<Fetch> = createToken('FetchForCsrfToken');\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport crypto from 'crypto';\nimport base64Url from 'base64-url';\n\nimport {SessionToken} from 'fusion-tokens';\nimport {html, createPlugin} from 'fusion-core';\nimport type {FusionPlugin, Middleware} from 'fusion-core';\n\nimport {\n  verifyMethod,\n  verifyExpiry,\n  CsrfIgnoreRoutesToken,\n  CsrfExpireToken,\n} from './shared';\nimport type {CsrfDepsType, CsrfServiceType} from './flow.js';\n\nfunction generateSecret() {\n  const random = crypto.randomBytes(32);\n  const escaped = base64Url.escape(random.toString());\n  return escaped.slice(0, 32);\n}\nfunction generateToken(secret) {\n  const timestamp = Math.round(Date.now() / 1000);\n  return tokenize(secret, timestamp.toString());\n}\nfunction verifyToken(secret, token) {\n  if (!secret || !token) return false;\n  const [timestamp] = token.split('-');\n  return token === tokenize(secret, timestamp);\n}\nfunction tokenize(secret, salt) {\n  const hmac = crypto\n    .createHmac('sha256', secret)\n    .update(salt)\n    .digest('base64');\n  return salt + '-' + base64Url.escape(hmac);\n}\n\nfunction loadOrGenerateSecret(session) {\n  let secret = session.get('csrf-secret');\n  if (!secret) {\n    secret = generateSecret();\n    session.set('csrf-secret', secret);\n  }\n  return secret;\n}\n\nconst plugin =\n  __NODE__ &&\n  createPlugin({\n    deps: {\n      Session: SessionToken,\n      expire: CsrfExpireToken.optional,\n      ignored: CsrfIgnoreRoutesToken.optional,\n    },\n    provides: () => () =>\n      Promise.reject(new Error('Cannot use fetch on the server')),\n    middleware: deps => {\n      const {Session = {}, expire = 86400, ignored = []} = deps;\n      const ignoreSet = new Set(ignored);\n      const handleTokenPost: Middleware = (ctx, next) => {\n        const session = Session.from(ctx);\n        const secret = loadOrGenerateSecret(session);\n        ctx.set('x-csrf-token', generateToken(secret));\n        ctx.status = 200;\n        ctx.body = '';\n        return next();\n      };\n\n      async function checkCSRF(ctx, next) {\n        const session = Session.from(ctx);\n\n        const token = ctx.headers['x-csrf-token'];\n        const secret = session.get('csrf-secret');\n        const isMatchingToken = verifyToken(secret, token);\n        const isValidToken = verifyExpiry(token, expire);\n        if (!isMatchingToken || !isValidToken) {\n          const message = __DEV__\n            ? 'CSRF Token configuration error: ' +\n              'Ensure you are using `fetch` from `fusion-plugin-csrf-protection-[react].'\n            : 'Invalid CSRF Token';\n          ctx.throw(403, message);\n        } else {\n          return next();\n        }\n      }\n\n      return async function csrfMiddleware(ctx, next) {\n        if (ctx.path === '/csrf-token' && ctx.method === 'POST') {\n          return handleTokenPost(ctx, next);\n        } else if (verifyMethod(ctx.method) && !ignoreSet.has(ctx.path)) {\n          return checkCSRF(ctx, next);\n        } else {\n          const session = Session.from(ctx);\n          const secret = loadOrGenerateSecret(session);\n          if (ctx.element) {\n            const token = generateToken(secret);\n            // $FlowFixMe\n            ctx.template.body.push(\n              html`<script id=\"__CSRF_TOKEN__\" type=\"application/json\">${JSON.stringify(\n                token\n              )}</script>`\n            );\n          }\n          return next();\n        }\n      };\n    },\n  });\n\nexport default ((plugin: any): FusionPlugin<CsrfDepsType, CsrfServiceType>);\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/* eslint-env browser */\nimport {unescape, createPlugin} from 'fusion-core';\nimport type {FusionPlugin} from 'fusion-core';\nimport type {Fetch} from 'fusion-tokens';\n\nimport {\n  verifyMethod,\n  verifyExpiry,\n  CsrfExpireToken,\n  FetchForCsrfToken,\n} from './shared';\nimport type {CsrfDepsType, CsrfServiceType} from './flow.js';\n\nconst plugin =\n  __BROWSER__ &&\n  createPlugin({\n    deps: {\n      fetch: FetchForCsrfToken,\n      expire: CsrfExpireToken.optional,\n    },\n    provides: ({fetch, expire = 86400}) => {\n      const prefix = window.__ROUTE_PREFIX__ || ''; // created by fusion-core/src/server\n      const tokenElement = document.getElementById('__CSRF_TOKEN__');\n\n      let token = tokenElement\n        ? JSON.parse(unescape(tokenElement.textContent))\n        : '';\n\n      let fetchWithCsrfToken: Fetch = (url, options) => {\n        if (!options) options = {};\n        // $FlowFixMe\n        const isCsrfMethod = verifyMethod(options.method || 'GET');\n        const isValid = verifyExpiry(String(token), expire);\n        const isTokenRequired = !isValid || !token;\n        if (isCsrfMethod && isTokenRequired) {\n          // TODO(#3) don't append prefix if injected fetch also injects prefix\n          return fetch(prefix + '/csrf-token', {\n            method: 'POST',\n            credentials: 'same-origin',\n          }).then(r => {\n            token = r.headers.get('x-csrf-token');\n            return request();\n          });\n        } else {\n          return request();\n        }\n\n        function request() {\n          // $FlowFixMe\n          return fetch(prefix + url, {\n            ...options,\n            credentials: 'same-origin',\n            headers: {\n              ...((options && options.headers) || {}),\n              'x-csrf-token': token,\n            },\n          });\n        }\n      };\n      return fetchWithCsrfToken;\n    },\n  });\n\nexport default ((plugin: any): FusionPlugin<CsrfDepsType, CsrfServiceType>);\n","/** Copyright (c) 2018 Uber Technologies, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport serverCsrf from './server.js';\nimport clientCsrf from './browser.js';\n\ndeclare var __NODE__: Boolean;\nexport default (__NODE__ ? serverCsrf : clientCsrf);\n\nexport {\n  FetchForCsrfToken,\n  CsrfExpireToken,\n  CsrfIgnoreRoutesToken,\n} from './shared';\n"],"names":["methods","POST","PUT","PATCH","DELETE","verifyMethod","method","verifyExpiry","token","expire","timestamp","split","elapsed","Math","round","Date","now","Number","isNaN","CsrfExpireToken","createToken","CsrfIgnoreRoutesToken","FetchForCsrfToken","plugin","createPlugin","deps","fetch","optional","provides","prefix","window","__ROUTE_PREFIX__","tokenElement","document","getElementById","JSON","parse","unescape","textContent","fetchWithCsrfToken","url","options","isCsrfMethod","isValid","String","isTokenRequired","credentials","then","r","headers","get","request","clientCsrf"],"mappings":";;AAAA;;;;;;;AAQA,AAIA,MAAMA,OAAO,GAAG;EAACC,IAAI,EAAE,CAAP;EAAUC,GAAG,EAAE,CAAf;EAAkBC,KAAK,EAAE,CAAzB;EAA4BC,MAAM,EAAE;CAApD;AAEA,AAAO,SAASC,YAAT,CACLC,MADK,EAEoB;SAClBN,OAAO,CAACM,MAAD,CAAd;;AAEF,AAAO,SAASC,YAAT,CAAsBC,KAAtB,EAAsCC,MAAtC,EAA+D;MAChE,CAACD,KAAL,EAAY,OAAO,KAAP;QACN,CAACE,SAAD,IAAcF,KAAK,CAACG,KAAN,CAAY,GAAZ,CAApB;QACMC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgCC,MAAM,CAACP,SAAD,CAAtD;MACIQ,KAAK,CAACN,OAAD,CAAL,IAAkBA,OAAO,GAAG,CAA5B,IAAiCA,OAAO,IAAIH,MAAhD,EAAwD,OAAO,KAAP;SACjD,IAAP;;AAGF,AAAO,MAAMU,eAA8B,GAAGC,WAAW,CAAC,iBAAD,CAAlD;AACP,AAAO,MAAMC,qBAA2C,GAAGD,WAAW,CACpE,uBADoE,CAA/D;AAGP,AAAO,MAAME,iBAA+B,GAAGF,WAAW,CAAC,mBAAD,CAAnD;;AC/BP;;;;;;;;;;;;;;;;;;;;;ACSA,AAYA,MAAMG,QAAM,GACV,QACAC,YAAY,CAAC;EACXC,IAAI,EAAE;IACJC,KAAK,EAAEJ,iBADH;IAEJb,MAAM,EAAEU,eAAe,CAACQ;GAHf;EAKXC,QAAQ,EAAE,CAAC;IAACF,KAAD;IAAQjB,MAAM,GAAG;GAAlB,KAA6B;UAC/BoB,MAAM,GAAGC,MAAM,CAACC,gBAAP,IAA2B,EAA1C,CADqC;;UAE/BC,YAAY,GAAGC,QAAQ,CAACC,cAAT,CAAwB,gBAAxB,CAArB;QAEI1B,KAAK,GAAGwB,YAAY,GACpBG,IAAI,CAACC,KAAL,CAAWC,QAAQ,CAACL,YAAY,CAACM,WAAd,CAAnB,CADoB,GAEpB,EAFJ;;QAIIC,kBAAyB,GAAG,CAACC,GAAD,EAAMC,OAAN,KAAkB;UAC5C,CAACA,OAAL,EAAcA,OAAO,GAAG,EAAV,CADkC;;YAG1CC,YAAY,GAAGrC,YAAY,CAACoC,OAAO,CAACnC,MAAR,IAAkB,KAAnB,CAAjC;YACMqC,OAAO,GAAGpC,YAAY,CAACqC,MAAM,CAACpC,KAAD,CAAP,EAAgBC,MAAhB,CAA5B;YACMoC,eAAe,GAAG,CAACF,OAAD,IAAY,CAACnC,KAArC;;UACIkC,YAAY,IAAIG,eAApB,EAAqC;;eAE5BnB,KAAK,CAACG,MAAM,GAAG,aAAV,EAAyB;UACnCvB,MAAM,EAAE,MAD2B;UAEnCwC,WAAW,EAAE;SAFH,CAAL,CAGJC,IAHI,CAGCC,CAAC,IAAI;UACXxC,KAAK,GAAGwC,CAAC,CAACC,OAAF,CAAUC,GAAV,CAAc,cAAd,CAAR;iBACOC,OAAO,EAAd;SALK,CAAP;OAFF,MASO;eACEA,OAAO,EAAd;;;eAGOA,OAAT,GAAmB;;eAEVzB,KAAK,CAACG,MAAM,GAAGW,GAAV,oBACPC,OADO;UAEVK,WAAW,EAAE,aAFH;UAGVG,OAAO,oBACAR,OAAO,IAAIA,OAAO,CAACQ,OAApB,IAAgC,EAD/B;4BAEWzC;;WALpB;;KArBJ;;WA+BO+B,kBAAP;;CA5CQ,CAFd;;ACrBA;;;;;;;AAQA,AAIA,YAAwCa,QAAxC;;;;;"}